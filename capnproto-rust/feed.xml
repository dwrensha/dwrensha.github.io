<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
        <channel>
                <title>Cap&apos;n Proto for Rust</title>
                <description>updates on capnproto-rust</description>
                <link>http://dwrensha.github.io/capnproto-rust</link>
                <atom:link href="http://dwrensha.github.io/capnproto-rust/feed.xml" rel="self" type="application/rss+xml" />
                
                        <item>
                                <title>0.18 — lazy UTF-8 and no-alloc</title>
                                <description>&lt;p&gt;New release alert!
Version 0.18 of &lt;a href=&quot;https://github.com/capnproto/capnproto-rust&quot;&gt;capnproto-rust&lt;/a&gt;
is now &lt;a href=&quot;https://crates.io/crates/capnp&quot;&gt;available on crates.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you use capnproto-rust on data with
the &lt;a href=&quot;https://capnproto.org/language.html#built-in-types&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt; built-in type&lt;/a&gt;,
then it’s likely that this release will require some
updates to your code.
But don’t worry — the changes are straightforward and they bring some
important benefits.&lt;/p&gt;

&lt;h2 id=&quot;lazy-utf-8-validation&quot;&gt;lazy UTF-8 validation&lt;/h2&gt;

&lt;p&gt;Suppose we have the following struct defined in a Cap’n Proto schema:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Foo {
  oneText @0 :Text;
  anotherText @1 :Text;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, in Rust, these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt; fields can be accessed through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt; type:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;one_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_one_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;another_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_another_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But what exactly is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt;?&lt;/p&gt;

&lt;h3 id=&quot;the-old-definition&quot;&gt;the old definition&lt;/h3&gt;

&lt;p&gt;In previous versions of capnproto-rust, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt; type
was an alias to Rust’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt; type:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At first glance, this seems like a perfect fit.
A Cap’n Proto &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt; value is required to
contain valid UTF-8 data, just like a Rust &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt;,
and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt; is meant to represent
a reference to that data.&lt;/p&gt;

&lt;p&gt;However, in practice, there are some ways in which this representation
falls short.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;performance&lt;/strong&gt;: Validating UTF-8 data has a cost,
and ideally we would like to avoid paying it multiple
times on the same data. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt; is just
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt;, then we need to validate every time that we:
    &lt;ul&gt;
      &lt;li&gt;copy a text field from one message to another,&lt;/li&gt;
      &lt;li&gt;write a text field to a file,&lt;/li&gt;
      &lt;li&gt;write a file to a text field, or&lt;/li&gt;
      &lt;li&gt;access some sub-range of a text field.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;This goes against the general Cap’n Proto philosophy
of doing validation as lazily as possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;robustness&lt;/strong&gt; – If a text field holds corrupted data, then
you still might want to be able to access that data, even
if it is not valid UTF-8. For example, imagine that a text
field holds log messages from a web server. We should
still be able to read the messages, even if they are garbled.
Indeed, garbled messages are probably the most interesting ones,
as they indicate unexpected behavior.
See &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/issues/314&quot;&gt;this issue&lt;/a&gt;
for more discussion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-new-definition&quot;&gt;the new definition&lt;/h3&gt;

&lt;p&gt;To address the above-noted shortcomings,
version 0.18 of capnproto-rust defines &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt;
like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cd&quot;&gt;/// Wrapper around utf-8 encoded text.&lt;/span&gt;
  &lt;span class=&quot;cd&quot;&gt;/// This is defined as a tuple struct to allow pattern matching&lt;/span&gt;
  &lt;span class=&quot;cd&quot;&gt;/// on it via byte literals (for example `text::Reader(b&quot;hello&quot;)`).&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;#[derive(Copy,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;Clone,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;PartialEq)]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;as_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;to_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Utf8Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Utf8Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;From&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;From&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now consumers can easily access the underlying data, via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as_bytes()&lt;/code&gt;,
and getting it as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; just requires an extra &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to_str()&lt;/code&gt;
or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to_string()&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;When setting text fields in a message, you will now need to
insert some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.into()&lt;/code&gt; calls to convert from a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;
into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text::Reader&lt;/code&gt;, like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;alice&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_one_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;my_foo&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_another_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello {name}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All this is admittedly more verbose than it was before,
but it’s in keeping with the general spirit of capnproto-rust:
we are willing to introduce some verbosity
if that’s what it takes to model Cap’n Proto data
in a satisfactory way.&lt;/p&gt;

&lt;h2 id=&quot;no-alloc-mode&quot;&gt;no-alloc mode&lt;/h2&gt;

&lt;p&gt;Another new feature is no-alloc mode.&lt;/p&gt;

&lt;p&gt;In version 0.13, capnproto-rust
&lt;a href=&quot;/capnproto-rust/2020/06/06/no-std-support.html&quot;&gt;gained support for no_std environments&lt;/a&gt;.
However, it still depended on the &lt;a href=&quot;https://doc.rust-lang.org/alloc/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;&lt;/a&gt; crate,
which can sometimes be a problem for microcontroller targets and kernel programming.
(See &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/issues/221&quot;&gt;this issue&lt;/a&gt;
for some discussion.)&lt;/p&gt;

&lt;p&gt;Starting with version 0.18, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; crate now has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt; Cargo feature,
which can be disabled to remove the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt; dependency.&lt;/p&gt;

&lt;p&gt;A side benefit of this change is that now error handling in capnproto-rust
is much less dependent on heap allocation, and so should have better
performance and be more reliable.&lt;/p&gt;

</description>
                                <pubDate>Mon, 04 Sep 2023 00:00:00 -0400</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2023/09/04/0.18-release.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2023/09/04/0.18-release.html</guid>
                        </item>
                
                        <item>
                                <title>run-time reflection</title>
                                <description>&lt;p&gt;Version 0.17 of
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust&quot;&gt;capnproto-rust&lt;/a&gt;
is now available!
It introduces support for dynamically typed values,
enabling a kind of run-time reflection.
The new functionality lets you write
ordinary Rust code to
iterate through the fields of any Cap’n Proto
&lt;a href=&quot;https://capnproto.org/language.html#structs&quot;&gt;struct&lt;/a&gt;,
with access to  names, types, and
&lt;a href=&quot;https://capnproto.org/language.html#annotations&quot;&gt;annotations&lt;/a&gt;.
Previously, you would have needed to use code generation or procedural
macros to achieve such things.&lt;/p&gt;

&lt;p&gt;This blog post will show two particular applications of reflection:
debug printing and generating random structured data.
The former has until now been sorely missing in capnproto-rust,
and the latter can yield (pretty?) pictures like this:&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;350&quot; src=&quot;/capnproto-rust/assets/shapes-000.svg&quot; alt=&quot;colorful randomly generated shapes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The post will also look at some details
of how the implementation of reflection works.&lt;/p&gt;

&lt;h2 id=&quot;debug-printing&quot;&gt;Debug Printing&lt;/h2&gt;

&lt;p&gt;A major motivation for adding reflection to capnproto-rust
is to implement the &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/trait.Debug.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debug&lt;/code&gt;&lt;/a&gt;
trait for all Cap’n Proto structs.
Because the data for such structs lives behind
a layer of indirection
(i.e. &lt;a href=&quot;/capnproto-rust/2014/12/27/custom-mutable-references.html&quot;&gt;synthetic references&lt;/a&gt;),
merely adding a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[derive(Debug)]&lt;/code&gt; annotation to the type declarations
would not be sufficient to print any useful information.
Instead, we need to add custom &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debug&lt;/code&gt; implementations
that read the underlying data.&lt;/p&gt;

&lt;p&gt;One way to achieve that would be to generate,
for each struct, separate implementation logic
which iterates through the struct fields and prints their values in sequence.
That’s the approach proposed by &lt;a href=&quot;https://github.com/as-com&quot;&gt;@as-com&lt;/a&gt;
in pull request &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/pull/390&quot;&gt;#390&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, now that we have reflection, we can avoid generating so much single-purpose
code. Instead, our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debug&lt;/code&gt; implementation for each struct immediately
delegates to a shared implementation that knows how to deal with
&lt;em&gt;any&lt;/em&gt; Cap’n Proto struct type. See
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/f7c86befe11b27f33c2a45957d402abff2b9e347/capnp/src/stringify.rs&quot;&gt;stringify.rs&lt;/a&gt;
if you are curious about what the code looks like.&lt;/p&gt;

&lt;p&gt;Using reflection in this way does have a (small)
run-time cost, as it requires
more branching than the static approach
implemented in &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/pull/390&quot;&gt;#390&lt;/a&gt;.
However, because it improves maintainability and
reduces code bloat (and therefore compile times!),
the cost seems worth paying.&lt;/p&gt;

&lt;p&gt;To see the new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debug&lt;/code&gt; functionality in action,
suppose that we have the following schema for an address book:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Person {
  id @0 :UInt32;
  name @1 :Text;
  email @2 :Text;
  phones @3 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }

  employment :union {
    unemployed @4 :Void;
    employer @5 :Text;
    school @6 :Text;
    selfEmployed @7 :Void;
  }
}

struct AddressBook {
  people @0 :List(Person);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address_book&lt;/code&gt; is a value of this type,
then we can print it with&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{:?}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and we get:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(people = [(id = 123, name = &quot;Alice&quot;, email = &quot;alice@example.com&quot;, phones = [(number = &quot;555-1212&quot;, type = mobile)], employment = (school = &quot;MIT&quot;)), (id = 456, name = &quot;Bob&quot;, email = &quot;bob@example.com&quot;, phones = [(number = &quot;555-4567&quot;, type = home), (number = &quot;555-7654&quot;, type = work)], employment = (unemployed = ()))])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The format here is the standard &lt;a href=&quot;https://github.com/capnproto/capnproto/blob/b2afb7f8fe393466a38e2fd2ad98482c34aafcee/c%2B%2B/src/capnp/serialize-text.h#L34-L40&quot;&gt;capnproto text format&lt;/a&gt;.
We can make it more readable via the &lt;a href=&quot;https://doc.rust-lang.org/std/fmt/struct.Formatter.html#method.alternate&quot;&gt;“alternate”&lt;/a&gt; flag.
If we print it with&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{:#?}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then we get:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
  people = [
    (
      id = 123,
      name = &quot;Alice&quot;,
      email = &quot;alice@example.com&quot;,
      phones = [
        (
          number = &quot;555-1212&quot;,
          type = mobile
        )
      ],
      employment = (
        school = &quot;MIT&quot;
      )
    ),
    (
      id = 456,
      name = &quot;Bob&quot;,
      email = &quot;bob@example.com&quot;,
      phones = [
        (
          number = &quot;555-4567&quot;,
          type = home
        ),
        (
          number = &quot;555-7654&quot;,
          type = work
        )
      ],
      employment = (
        unemployed = ()
      )
    )
  ]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;filling-in-random-values&quot;&gt;Filling in Random Values&lt;/h2&gt;

&lt;p&gt;Reflection also makes it easy to generate random values of any
Cap’n Proto type, as might be useful
in various kinds of testing.
The new directory
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/tree/master/example/fill_random_values&quot;&gt;fill_random_values&lt;/a&gt;
contains some example code
illustrating this idea.&lt;/p&gt;

&lt;h3 id=&quot;random-addressbook&quot;&gt;Random Addressbook&lt;/h3&gt;

&lt;p&gt;If we take the address book schema discussed above
and plug it into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill_random_values&lt;/code&gt;,
the output looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
  people = [
    (
      id = 640675312,
      name = &quot;i&quot;,
      email = &quot;npcvojhliloc&quot;,
      phones = [
        (
          number = &quot;y&quot;,
          type = mobile
        ),
        (
          number = &quot;mfqhbgmtgmbkyslpw&quot;,
          type = work
        ),
        (
          number = &quot;&quot;,
          type = home
        ),
        (
          number = &quot;yi&quot;,
          type = work
        ),
        (
          number = &quot;vgcqfrhqlparbptuwu&quot;,
          type = home
        ),
        (
          number = &quot;qkhyxjplpufjlxknp&quot;,
          type = mobile
        ),
        (
          number = &quot;oyenjhvaikluhpoedkj&quot;,
          type = work
        ),
        (
          number = &quot;y&quot;,
          type = work
        )
      ],
      employment = (
        unemployed = ()
      )
    ),
    (
      id = 3188155808,
      name = &quot;mpe&quot;,
      email = &quot;vgqcfacrnhqrqxe&quot;,
      phones = [],
      employment = (
        employer = &quot;aobikqcv&quot;
      )
    ),
    ...
  ]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s definitely some random gibberish!&lt;/p&gt;

&lt;p&gt;To make the output more “realistic”,
we can constrain the values
of the fields using some annotations from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill.capnp&lt;/code&gt;.
We might mark up the schema like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using Fill = import &quot;fill.capnp&quot;;
using Corpora = import &quot;corpora.capnp&quot;;

struct Person {
  id @0 :UInt32;
  name @1 :Text $Fill.SelectFrom(List(Text)).choices(Corpora.scientists);
  email @2 :Text $Fill.SelectFrom(List(Text)).choices(Corpora.emails);
  phones @3 :List(PhoneNumber) $Fill.lengthRange((max = 3));

  struct PhoneNumber {
    number @0 :Text $Fill.phoneNumber;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }

  employment :union {
    unemployed @4 :Void;
    employer @5 :Text $Fill.SelectFrom(List(Text)).choices(Corpora.corporations);
    school @6 :Text $Fill.SelectFrom(List(Text)).choices(Corpora.schools);
    selfEmployed @7 :Void;
  }
}

struct AddressBook {
  people @0 :List(Person) $Fill.lengthRange((max = 5));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Annotations are signified by the dollar sign &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;. For example,
the line&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  phones @3 :List(PhoneNumber) $Fill.lengthRange((max = 3));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;tells the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill_random_values&lt;/code&gt; library
that the value in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phones&lt;/code&gt; field should have length at most 3,
and the line&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  name @1 :Text $Fill.SelectFrom(List(Text)).choices(Corpora.scientists);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;indicates that the value for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;
field should be chosen the list of choices given by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Corpora.scientists&lt;/code&gt; constant,
which is defined in the schema file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;corpora.capnp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is some example output after these constraints are applied:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
  people = [
    (
      id = 2252764513,
      name = &quot;Willard Gibbs&quot;,
      email = &quot;c@example.com&quot;,
      phones = [
        (
          number = &quot;985-555-1858&quot;,
          type = mobile
        ),
        (
          number = &quot;558-555-1461&quot;,
          type = work
        ),
        (
          number = &quot;585-555-1163&quot;,
          type = home
        )
      ],
      employment = (
        school = &quot;Penn State&quot;
      )
    ),
    (
      id = 2222057070,
      name = &quot;Joseph Priestley&quot;,
      email = &quot;carol@example.com&quot;,
      phones = [
        (
          number = &quot;149-555-1350&quot;,
          type = work
        ),
        (
          number = &quot;685-555-1721&quot;,
          type = home
        ),
        (
          number = &quot;818-555-1428&quot;,
          type = home
        )
      ],
      employment = (
        employer = &quot;LKQ Corporation&quot;
      )
    )
  ]
)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That looks better!
You can imagine that maybe the code you are testing
does some basic validation on its inputs,
and that values generated in this way are more likely to pass the validation,
and therefore can achieve better code coverage.&lt;/p&gt;

&lt;h3 id=&quot;random-shapes&quot;&gt;Random Shapes&lt;/h3&gt;

&lt;p&gt;To illustrate some of the other capabilities of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill_random_values&lt;/code&gt;,
here is a schema describing a recursive geometric grammar,
with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill_random_values&lt;/code&gt; annotations already added:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using Fill = import &quot;fill.capnp&quot;;

struct Color {
  red   @0 : UInt8;
  green @1 : UInt8;
  blue  @2 : UInt8;
}

struct Point {
  # A point in normalized coordinates. (0,0) is the upper-left of
  # the current subcanvas, and (1,1) is the lower-right of the
  # current subcanvas.

  x @0 : Float64 $Fill.float64Range((min = 0.0, max = 1.0));
  y @1 : Float64 $Fill.float64Range((min = 0.0, max = 1.0));
}

struct Line {
  start @0 : Point;
  end   @1 : Point;

  thickness @2 : Float64 $Fill.float64Range((min = 0.01, max = 0.95));
  # Stroke width as a percent of the current subcanvas&apos;s diagonal length.

  color @3 : Color;
}

struct Circle {
  center @0 : Point;
  # The center of the circle.

  radius @1 : Float64 $Fill.float64Range((min = 0.01, max = 0.25));
  # The radius of the circle, as a proportion of the current
  # subcanvas&apos;s diagonal length.

  fillColor @2 : Color;
}

struct Subcanvas {
  # A canvas contained in a larger canvas.

  center @0 : Point;
  width @1 : Float64 $Fill.float64Range((min = 0.0, max = 1.0));
  height @2 : Float64 $Fill.float64Range((min = 0.0, max = 1.0));
  canvas @3 : Canvas;
}

struct Canvas {
  # A canvas containing some geometric elements.

  backgroundColor @0 : Color;
  lines @1 : List(Line) $Fill.lengthRange((max = 5));
  circles @2 : List(Circle) $Fill.lengthRange((max = 5));
  subcanvases @3 : List(Subcanvas) $Fill.lengthRange((max = 3));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can pass this to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill_random_values&lt;/code&gt;
and then render the output as SVGs, yielding:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-001.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-002.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-003.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-004.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-005.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-006.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-007.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-008.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-009.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I think these are fun! But the colors are maybe a bit too wild for my taste.
What if we fixed a color palette?
To that end, we define a constant:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const palette: List(Color) = [
 (red = 0x22, green = 0xd7, blue = 0xb5),
 (red = 0x11, green = 0xb1, blue = 0x86),
 (red = 0x7c, green = 0xa4, blue = 0xf5),
 (red = 0xe7, green = 0x60, blue = 0x1d),
 (red = 0x25, green = 0x23, blue = 0x25),
 (red = 0x89, green = 0x74, blue = 0x59),
];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and then we annotate the color fields like this:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  color @3 : Color $Fill.SelectFrom(List(Color)).choices(.palette);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now the output, with constrained colors, looks like:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-001.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-002.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-003.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-004.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-005.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-006.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-007.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-008.svg&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img width=&quot;195&quot; src=&quot;/capnproto-rust/assets/shapes-palette-009.svg&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now that’s starting to look like something I might frame and hang on a wall.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How It Works&lt;/h2&gt;

&lt;p&gt;The implementation of reflection
in capnproto-rust largely follows
the original implementation of reflection
in &lt;a href=&quot;https://github.com/capnproto/capnproto&quot;&gt;capnproto-c++&lt;/a&gt;.
The main idea is to
stash type descriptions in the generated code.&lt;/p&gt;

&lt;p&gt;The schema compiler plugin (capnpc-rust or capnpc-c++)
receives its input as a
&lt;a href=&quot;https://github.com/capnproto/capnproto/blob/b2afb7f8fe393466a38e2fd2ad98482c34aafcee/c%2B%2B/src/capnp/schema.capnp#L498-L542&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CodeGeneratorRequest&lt;/code&gt;&lt;/a&gt;
Cap’n Proto message,
containing a list of
&lt;a href=&quot;https://github.com/capnproto/capnproto/blob/b2afb7f8fe393466a38e2fd2ad98482c34aafcee/c%2B%2B/src/capnp/schema.capnp#L30-L199&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;&lt;/a&gt;
values that describe all of the user-declared types.
To support reflection, we save these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; values
as static constants, and we make them available (in Rust) via
an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Introspect&lt;/code&gt; trait:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Introspect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;introspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Type&lt;/code&gt; type represents a recursive data structure that can describe
any &lt;a href=&quot;https://capnproto.org/language.html#language-reference&quot;&gt;Cap’n Proto type&lt;/a&gt;.
Usually, recursive data structures require some form of heap allocation
to avoid having infinite size.
In this case, however, we achieve the necessary indirection
by holding static references to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; values in the generated code.
This allows the entire reflection system to work
without needing any heap allocation.&lt;/p&gt;

&lt;p&gt;(Note that this setup implies that reflection is only possible on types
that are known at compile time.
The C++ implementation does offer further support for registering new types at
run time, but adding such support in Rust would require a significant amount of
additional effort.)&lt;/p&gt;

&lt;p&gt;One tricky of all this is
the fact that Cap’n Proto has
&lt;a href=&quot;https://capnproto.org/language.html#generic-types&quot;&gt;generic types&lt;/a&gt;.
That is, structs can have type parameters.
We need to be able to retrieve information about such structs
&lt;em&gt;after applying type substitution&lt;/em&gt; for those parameters.&lt;/p&gt;

&lt;p&gt;The C++ implementation
has a &lt;a href=&quot;https://github.com/capnproto/capnproto/blob/b2afb7f8fe393466a38e2fd2ad98482c34aafcee/c%2B%2B/src/capnp/raw-schema.h#L40-L42&quot;&gt;scary comment&lt;/a&gt;
about how it solves this problem:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Note that while we generate one `RawSchema` per type, we generate a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// `RawBrandedSchema` for every _instance_ of a generic type -- or, at&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// least, every instance that is actually used. For generated-code types,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// we use template magic to initialize these.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rust most assuredly does not have “template magic”,
so it’s not immediately clear how to solve the equivalent problem in Rust.&lt;/p&gt;

&lt;p&gt;Fortunately,
while Rust does not support type-parameterized static variables,
it does support type-parameterized functions,
and we can push type resolution logic into a
&lt;em&gt;function&lt;/em&gt; generated for every Cap’n Proto struct type:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_field_types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;field_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;introspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you retrieve a field of a dynamic struct in capnproto-rust,
the implemention will call the underlying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_field_types()&lt;/code&gt; method
to retrieve the type of the field.
It will then return to you a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic_value::Reader&lt;/code&gt; tagged with that type.&lt;/p&gt;

&lt;h2 id=&quot;ideas-for-future-projects&quot;&gt;Ideas for Future Projects&lt;/h2&gt;

&lt;p&gt;Reflection has a wide range of possible applications,
including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Automatic conversion between Cap’n Proto data and
various self-describing formats such JSON and XML.&lt;/li&gt;
  &lt;li&gt;Structure-aware fuzz testing and fault injection.&lt;/li&gt;
  &lt;li&gt;Database adapters.&lt;/li&gt;
  &lt;li&gt;Analysis tools for structured logs.&lt;/li&gt;
  &lt;li&gt;Conversion between Cap’n Proto data and native Rust structs, perhaps using some of the existing or future reflection features described in this
&lt;a href=&quot;https://soasis.org/posts/a-mirror-for-rust-a-plan-for-generic-compile-time-introspection-in-rust/&quot;&gt;recent Shepherd’s Oasis blog post&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m excited to see what users come up with!&lt;/p&gt;
</description>
                                <pubDate>Mon, 08 May 2023 00:00:00 -0400</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2023/05/08/run-time-reflection.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2023/05/08/run-time-reflection.html</guid>
                        </item>
                
                        <item>
                                <title>out-of-bounds memory access bug</title>
                                <description>&lt;p&gt;Recent fuzz testing has uncovered a bug in
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust&quot;&gt;capnproto-rust&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/capnproto/capnproto&quot;&gt;capnproto-c++&lt;/a&gt;
that allows out-of-bounds memory to be accessed in certain situations.&lt;/p&gt;

&lt;p&gt;If a message consumer expects data
of type “list of pointers”,
and if the consumer performs certain specific actions on such data,
then a message producer can
cause the consumer to read out-of-bounds memory.
This could trigger a process crash in the consumer,
or in some cases could allow exfiltration of private in-memory data.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&quot;https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md&quot;&gt;advisory&lt;/a&gt;
on the main Cap’n Proto repo for a succinct description of
the exact circumstances in which the problem can arise,
and for information about how to update the Cap’n Proto C++ library.&lt;/p&gt;

&lt;p&gt;If you use the &lt;a href=&quot;https://crates.io/crates/capnp&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt;&lt;/a&gt; Rust crate,
you are advised to update to a version that includes the fix —
currently either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.15.2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.14.11&lt;/code&gt;, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.13.7&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;timeline&quot;&gt;Timeline&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;March 2013&lt;/strong&gt;: Cap’n Proto is implemented in C++ and early versions already contain the bug.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;July 2013&lt;/strong&gt;: The initial capnproto-rust implementation copies the C++ implementation, bug and all.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;February 2017&lt;/strong&gt;: Two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo fuzz&lt;/code&gt; test targets
(named
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/28be3364441ffd0fbfc3ecb2bf9800bb5fcad3a9&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;canonicalize&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/55a38058d69ffdaeb0204e8b91ef1d01f86a19f8&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_all_types&lt;/code&gt;&lt;/a&gt;)
are added
to the capnproto-rust repo. Initial findings are reported in
&lt;a href=&quot;https://dwrensha.github.io/capnproto-rust/2017/02/27/cargo-fuzz.html&quot;&gt;a blog post&lt;/a&gt;.
The out-of-bounds bug is not found, due to insufficient coverage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;11 November 2022&lt;/strong&gt;: The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_all_types&lt;/code&gt; fuzz test target is
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/ab575a0c5841104cb726a018951e5105797414e3&quot;&gt;expanded&lt;/a&gt;
to achieve additional coverage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;(later) 11 November 2022&lt;/strong&gt;: A several-hour run of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo fuzz -j 25&lt;/code&gt; triggers an
Address Sanitizer error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;12 November 2022&lt;/strong&gt;: The bug is diagnosed and determined to also apply to capnproto-c++. A report is sent to &lt;a href=&quot;mailto:kenton@cloudflare.com&quot;&gt;kenton@cloudflare.com&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;30 November 2022&lt;/strong&gt;: Fixes are released. Security advisory is published as
&lt;a href=&quot;https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx&quot;&gt;CVE-2022-46149&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;technical-explanation&quot;&gt;Technical Explanation&lt;/h2&gt;

&lt;p&gt;The bug arises from an interaction between a core feature of Cap’n Proto
(type-agnostic copying) and an optimization
(list pointer &lt;a href=&quot;https://github.com/capnproto/capnproto/blob/fd508f325ed65f9d6cdf10a0f4511aa53b5659fc/c%2B%2B/src/capnp/layout.c%2B%2B#L2363-L2366&quot;&gt;munging&lt;/a&gt;)
which failed to correctly take that feature into account.&lt;/p&gt;

&lt;h3 id=&quot;capn-proto-core-feature-type-agnostic-copying&quot;&gt;Cap’n Proto core feature: type-agnostic copying&lt;/h3&gt;

&lt;p&gt;Types of Cap’n Proto messages are defined
in schema files, as described
in the &lt;a href=&quot;https://capnproto.org/language.html&quot;&gt;language reference&lt;/a&gt;.
To be given meaning,
a Cap’n Proto message must be ascribed
a type.&lt;/p&gt;

&lt;p&gt;Nevertheless,
many operations on Cap’n Proto messages
can proceed without reference to these high-level types.
At a low level, Cap’n Proto messages have
a simple self-describing
structure, divided into two components:
primitive data and pointers.&lt;/p&gt;

&lt;p&gt;Primitive data is flat and opaque.
It consists of bytes that can
be interpreted as scalar values of type
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UInt8&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UInt16&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UInt32&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UInt32&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UInt64&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int8&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int16&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int64&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Float32&lt;/code&gt;, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Float64&lt;/code&gt;.
The interpretation as scalar values is
&lt;em&gt;not&lt;/em&gt; a self-describing part of a message;
it requires the message to be ascribed
a high-level type via a schema.&lt;/p&gt;

&lt;p&gt;Pointers introduce indirection, pointing
to either structs or lists
(or capabilities in the
&lt;a href=&quot;https://capnproto.org/rpc.html&quot;&gt;RPC&lt;/a&gt; system).
A &lt;a href=&quot;https://capnproto.org/encoding.html#structs&quot;&gt;struct&lt;/a&gt;
is a container with a data section
holding some amount of primitive data,
and a pointer section holding some number of pointers.
A &lt;a href=&quot;https://capnproto.org/encoding.html#lists&quot;&gt;list&lt;/a&gt;
is a sequence of elements, each containing
some amount of primitive data and some number of pointers.
For both struct and list pointers,
the pointer itself describes
the size of the contents, i.e. number of primitive
data bytes and number of pointers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/capnproto-rust/assets/message-structure.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The above diagram shows the structure of an example 4-word (32-byte) message.
A struct pointer points to a 1-word data section, containing
8 bytes of primitive data, and a 1-word pointer section,
containing a list pointer. The list pointer points
to an 8-element list of bytes (also primitive data).&lt;/p&gt;

&lt;p&gt;This low-level structure provides enough information on its own
to support traversal, copying,
and even &lt;a href=&quot;https://capnproto.org/encoding.html#canonicalization&quot;&gt;canonicalization&lt;/a&gt;
of Cap’n Proto messages,
without reference to high-level schema information.&lt;/p&gt;

&lt;p&gt;Let’s look at some code in a concrete example where
copying in particular comes into play.
Consider the following schema.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Record {
   x @0 :Int32;
   y @1 :Int32;
   comments @2 :Text;
}

struct Input {
   record @0 :Record;
   tags   @1 :List(Text);

   # ... plus other Input-specific fields
}

struct Output {
   record @0 :Record;
   tags   @1 :List(Text);

   # ... plus other Output-specific fields
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Imagine a setup where Alice sends an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; to Bob,
who does some processing, and then sends
an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Output&lt;/code&gt; to Carol.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/capnproto-rust/assets/alice-bob-carol.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s say that part of Bob’s processing is to forward the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tags&lt;/code&gt; fields of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; into the
corresponding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt; fields of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Output&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The Cap’n Proto schema compiler generates Rust code for Bob
including something like the following:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;get_record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;get_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;text_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;set_record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;set_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;text_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And now Bob, to copy the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tags&lt;/code&gt; fields
from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Output&lt;/code&gt;,
will write some lines of Rust code like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So far, this all may seem rather straightforward and boilerplatish,
but there’s an important thing happening behind the scenes.
Namely, the implementations of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_record()&lt;/code&gt;
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_tags()&lt;/code&gt; delegate to &lt;em&gt;type-agnostic&lt;/em&gt;
copying functions, which operate only on the
low-level structure of the underlying messages.
That is, even though we know the high-level
types of the values that are being copied,
we ignore that information when we actually perform the copying.&lt;/p&gt;

&lt;p&gt;There two primary advantages to this approach:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Code bloat is minimized. Rather than generating separate
  copying logic for each setter method of a struct or list field,
  we instead always delegate to the same type-agnostic
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_struct_pointer()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_list_pointer()&lt;/code&gt; functions.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://capnproto.org/language.html#evolving-your-protocol&quot;&gt;Protocol evolution&lt;/a&gt;
  is automatically supported. If Alice starts using a newer version of the schema,
  Bob will faithfully forward any new fields to Carol,
  even if Bob does not understand the meaning of those fields.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To elaborate on (2), suppose that the schema evolves to:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Record {
   x @0 :Int32;
   y @1 :Int32;
   comments @2 :Text;
   key @3 :UInt64; # new field
}

Struct Tag {
   name @0 :Text;
   weight @1 :Float32;
}

struct Input {
   record @0 :Record;
   tags   @1 :List(Tag); # upgraded from List(Text)

   # ... plus other Input-specific fields
}

struct Output {
   record @0 :Record;
   tags   @1 :List(Tag); # upgraded from List(Text)

   # ... plus other Output-specific fields
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here we’ve added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt; field to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Record&lt;/code&gt;,
and we’ve upgraded the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tags&lt;/code&gt; field from
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List(Text)&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List(Tag)&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tag&lt;/code&gt; is
a newly-added struct.
From an encoding perspective,
these schema evolutions mean that:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Record&lt;/code&gt; will now have an additional 8 bytes of primitive
data in its data section.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tags&lt;/code&gt; field will now encoded as a list of structs,
rather than a list of list of bytes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The point is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_struct_pointer()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_list_pointer()&lt;/code&gt;
functions automatically deal with these changes,
so Bob does not need to know about the schema evolution;
his existing code already faithfully forwards the new data to Carol.&lt;/p&gt;

&lt;h3 id=&quot;bad-optimization-munged-list-pointers&quot;&gt;Bad optimization: munged list pointers&lt;/h3&gt;

&lt;p&gt;So far so good.
To understand the bug, we’ll need to dig deeper
into how capnproto-rust internally represents lists.
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text_list::Reader&amp;lt;&apos;a&amp;gt;&lt;/code&gt; Rust struct returned by
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_tags()&lt;/code&gt; method above is a shallow wrapper
around a Rust struct called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[derive(Clone,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;Copy)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Mediated access to the rest of the message&apos;s bytes.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;arena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dyn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReaderArena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Which segment from the arena this list lives on.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;segment_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Handles to any capabilities in the message.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cap_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CapTableReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Pointer to the start of the first element in the list.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (Except when &quot;munged&quot;. See below.)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Number of elements in the list.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;element_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementCount32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Number of bits per list element.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitCount32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// The size of each element of the list.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;element_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// If element_size is InlineComposite, then this is the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// number of bits in each struct element&apos;s data section.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Otherwise, it is zero.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;struct_data_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitCount32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// If element_size is InlineComposite, then this is the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// number of pointers in each struct element&apos;s pointer section.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Otherwise, it is zero.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;struct_pointer_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WirePointerCount16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// How many more pointers we are allowed to follow before&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// returning an error.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nesting_limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;There’s a lot of bookkeeping happening here.
The main idea is that we have pointer to the first element of the list,
plus information about the size of each element.&lt;/p&gt;

&lt;p&gt;To retrieve the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;th element from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tl: text_list::Reader&amp;lt;&apos;a&amp;gt;&lt;/code&gt;,
we do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tl.get(n)?&lt;/code&gt;, which delegates
to the following &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader&lt;/code&gt; method:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_pointer_element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementCount32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PointerReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The logic in this method is roughly:
start at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.ptr&lt;/code&gt; and take an offset of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.step / 8 * index&lt;/code&gt; bytes.
For a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text_list::Reader&amp;lt;&apos;a&amp;gt;&lt;/code&gt;, it’s usually the
case that its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader&lt;/code&gt; has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element_size == Pointer&lt;/code&gt;
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step == 64&lt;/code&gt; (i.e. one word),
so in that case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pointer_element(index)&lt;/code&gt; returns the pointer
that at an offset of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8 * index&lt;/code&gt; from the front of the list.&lt;/p&gt;

&lt;p&gt;But what happens if
the underlying list is actually a struct list
(i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element_size == InlineComposite&lt;/code&gt;)?
As we saw above, that can happen as a consequence of protocol
evolution, if Alice constructs a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List(Tag)&lt;/code&gt; but Bob still
expects to read it as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List(Text)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To deal with that case, we need to also take into account
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.struct_data_size&lt;/code&gt;. The pointer that we want
will be the &lt;em&gt;first&lt;/em&gt; pointer in the pointer section of the struct,
but there may be a nonempty data section that we need to skip first.
So the logic in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pointer_element()&lt;/code&gt; needs to be:
start at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.ptr&lt;/code&gt; and take an offset of
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.step / 8 * index + self.struct_data_size / 8&lt;/code&gt; bytes.&lt;/p&gt;

&lt;p&gt;And here we might be tempted to make an optimization.
Notice that the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.struct_data_size / 8&lt;/code&gt; term
gets added on &lt;em&gt;every&lt;/em&gt; call of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pointer_element()&lt;/code&gt;.
What if we added that value just once, when we first
constructed the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader&lt;/code&gt;? Then maybe we could eliminate
some instructions and squeeze out a few more bits of performance.&lt;/p&gt;

&lt;p&gt;The original Cap’n Proto implementation included this optimization,
where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader.ptr&lt;/code&gt; would be “munged” by an offset
corresponding to the struct data size.
As long as all access to the list
goes through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pointer_element()&lt;/code&gt; method,
the optimization works without any problems.&lt;/p&gt;

&lt;p&gt;Type-agnostic copying, however, does &lt;em&gt;not&lt;/em&gt; go through that method.
We hit trouble when we pass a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader&lt;/code&gt; with
such a munged pointer into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_list_pointer()&lt;/code&gt; function
described in the previous section.
That function has no way to know where a list pointer has been munged or not,
and expects &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListReader.ptr&lt;/code&gt; to always point to the &lt;em&gt;start&lt;/em&gt;
of the first element of the list.
Therefore, when it receives a munged pointer,
it will start reading from it at an offset of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct_data_size&lt;/code&gt;
past where it should.
If the end of the message segment is within
that offset, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_list_pointer()&lt;/code&gt; can read out-of-bounds data,
from beyond the end of the message.&lt;/p&gt;

&lt;h3 id=&quot;fixing-the-bug&quot;&gt;Fixing the bug&lt;/h3&gt;

&lt;p&gt;The bug is fixed by commit &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/e7ee0ef892c354b0390ed6e38d3ca634308897c5&quot;&gt;e7ee0ef892c354b0390ed6e38d3ca634308897c5&lt;/a&gt;,
which eliminates the bad optimization.&lt;/p&gt;
</description>
                                <pubDate>Wed, 30 Nov 2022 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</guid>
                        </item>
                
                        <item>
                                <title>0.15 — GATs, CapabilityServerSet, and async packing</title>
                                <description>&lt;p&gt;Today I am releasing version 0.15.0 of the capnproto-rust crates:
&lt;a href=&quot;https://crates.io/crates/capnp&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;https://crates.io/crates/capnpc&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnpc&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;https://crates.io/crates/capnp-futures&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp-futures&lt;/code&gt;&lt;/a&gt;,
and &lt;a href=&quot;https://crates.io/crates/capnp-rpc&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp-rpc&lt;/code&gt;&lt;/a&gt;.
It’s been a while – almost two years since the
&lt;a href=&quot;/capnproto-rust/2020/12/19/atomic-read-limiting.html&quot;&gt;0.14.0 release&lt;/a&gt;!
So what’s new?&lt;/p&gt;

&lt;h2 id=&quot;generic-associated-types&quot;&gt;Generic Associated Types&lt;/h2&gt;

&lt;p&gt;Say we have a Cap’n Proto &lt;a href=&quot;https://capnproto.org/language.html&quot;&gt;schema&lt;/a&gt;
that defines a struct type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Foo {
  id @0 :UInt64;
  payload @1 :Data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When we pass this to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnpc-rust&lt;/code&gt; code generator, it
gives us declarations for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Reader&amp;lt;&apos;a&amp;gt;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Builder&amp;lt;&apos;b&amp;gt;&lt;/code&gt; types.
These types act as
“&lt;a href=&quot;/capnproto-rust/2014/12/27/custom-mutable-references.html&quot;&gt;synthetic references&lt;/a&gt;”,
allowing us to
read a capnp-encoded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&lt;/code&gt; value directly from a byte buffer without
copying it into an intermediate structure.
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Reader&amp;lt;&apos;a&amp;gt;&lt;/code&gt; type acts like an immutable (shared) reference &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&apos;a Foo&lt;/code&gt;,
and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Builder&amp;lt;&apos;a&amp;gt;&lt;/code&gt; type acts like a mutable reference &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&apos;a mut Foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Very well, but what if we now want to define
a generic container type for a Cap’n Proto message,
whose contents can be borrowed either immutably or mutably?
Something like:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MessageContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HeapAllocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;nn&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhantomData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MessageContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We want to be able to plug &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&lt;/code&gt; (or any other Cap’n Proto struct type)
in for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; here. How do we fill in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;???&lt;/code&gt; to make this work?&lt;/p&gt;

&lt;p&gt;The key is that, in addition to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Reader&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Builder&lt;/code&gt;,
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnpc-rust&lt;/code&gt; code generator also generates
a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Owned&lt;/code&gt; type, meant as a stand in for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo&lt;/code&gt; itself
(which cannot be directly represented in Rust).
The type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo::Owned&lt;/code&gt; has the following impl:&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;traits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::traits::Owned&lt;/code&gt; is defined as&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromPointerReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetPointerBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromPointerBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we can fill in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MessageContainer&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MessageContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;traits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HeapAllocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;nn&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhantomData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MessageContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;traits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that the lifetime parameters on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Owned::Reader&lt;/code&gt;
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Owned::Builder&lt;/code&gt; make them
&lt;a href=&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;generic associated types&lt;/a&gt;,
a newly stablized feature of Rust.&lt;/p&gt;

&lt;h3 id=&quot;how-it-worked-before-gat&quot;&gt;How it worked before GAT&lt;/h3&gt;

&lt;p&gt;In previous versions of capnproto-rust,
we needed to hoist the lifetime parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&apos;a&amp;gt;&lt;/code&gt; to the top
of the declaration of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::traits::Owned&lt;/code&gt;, like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromPointerReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetPointerBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromPointerBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, usages of the trait often needed higher rank trait bounds (i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&amp;lt;&apos;a&amp;gt;...&lt;/code&gt;),
like this:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MessageContainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;traits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&apos;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;capnp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HeapAllocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;nn&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PhantomData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&amp;lt;&apos;a&amp;gt;&lt;/code&gt; syntax makes this trait look more complicated than it actually is,
so it’s good that we are finally able to remove it!&lt;/p&gt;

&lt;h2 id=&quot;capabilityserverset&quot;&gt;CapabilityServerSet&lt;/h2&gt;

&lt;p&gt;Consider the following (over)simplified version of
Sandstorm’s &lt;a href=&quot;https://github.com/sandstorm-io/sandstorm/blob/d8be67ad5f703bb73f5da4e607cce07106c2a0f1/src/sandstorm/web-publishing.capnp#L24-L98&quot;&gt;web publishing interface&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface BlobHandle {}

interface BlobWriter {
  write @0 (chunk: Data);
  done @1 () -&amp;gt; (handle :BlobHandle);
}

interface WebSitePublisher {
  createBlob @0 () -&amp;gt; (writer :BlobWriter);
  set @1 (path :Text, blob :BlobHandle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To add some piece of content to a web site, an consumer of this API would do the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createBlob()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Write to the blob using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobWriter.write()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobWriter.done()&lt;/code&gt; to get a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandle&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Pass the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandle&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebSitePublisher.set()&lt;/code&gt; for each path that should serve the content.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This flow allows uploads to be streamed (step 2),
and it allows a single piece of content to be pushed to multiple paths
(step 4) without duplicated work.&lt;/p&gt;

&lt;p&gt;But how is the server supposed to implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebSitePublisher.set()&lt;/code&gt;?
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandle&lt;/code&gt; that it receives does not have any methods,
so how can anything meaningful be done with it?&lt;/p&gt;

&lt;p&gt;Let’s first translate the question into Rust code.
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnpc-rust&lt;/code&gt;-generated code for the above schema will contain
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Client&lt;/code&gt; structs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_handle::Client&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_writer::Client&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_site_publisher::Client&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server&lt;/code&gt; traits
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_handle::Server&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_writer::Server&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_site_publisher::Server&lt;/code&gt;.
The idea is that the server will implement the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server&lt;/code&gt; traits,
with structs named perhaps &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandleImpl&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobWriterImpl&lt;/code&gt;,
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebSitePublisherImpl&lt;/code&gt;, and then will pass these
structs to RPC system via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp_rpc::new_client()&lt;/code&gt; function.
For example, to create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandle&lt;/code&gt;, the implementation
of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_writer::Server::done()&lt;/code&gt; might do:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blob_handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BlobHandleImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blob_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;blob_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;capnp_rpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blob_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The issue is that once we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp_rpc::new_client()&lt;/code&gt; we no longer have
access to the underlying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandleImpl&lt;/code&gt; object,
so by the time we are in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_site_publisher::Server::set()&lt;/code&gt;, we cannot
get to the blob’s bytes.&lt;/p&gt;

&lt;p&gt;The solution is to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CapabilityServerSet&lt;/code&gt;,
a feature that has existed in capnproto-c++
for a long time, and as of today has been added to capnproto-rust.
If a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob_handle::Client&lt;/code&gt; is created via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CapabilityServerSet::new_client()&lt;/code&gt;,
instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp_rpc::new_client()&lt;/code&gt;,
then its underlying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlobHandleImpl&lt;/code&gt; can later be retrieved
via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CapabilityServerSet::get_local_server()&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CapabilityServerSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlobHandleImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;blob_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;CapabilityServerSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blob_handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BlobHandleImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blob_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;blob_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.new_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blob_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_site_publisher::Server&lt;/code&gt; could do:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_local_client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;.await&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// s has type `&amp;amp;Rc&amp;lt;RefCell&amp;lt;BlobHandleImpl&amp;gt;&amp;gt;`&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;async-packing&quot;&gt;Async Packing&lt;/h2&gt;

&lt;p&gt;Cap’n Proto’s
&lt;a href=&quot;https://capnproto.org/encoding.html#packing&quot;&gt;packed codec&lt;/a&gt;
is a way to reduce message size in exchange for
a minimal encoding/decoding cost.&lt;/p&gt;

&lt;p&gt;Until recently, capnproto-rust only support the packed codec
via the synchronous &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::serialize_packed&lt;/code&gt; API; if you
wanted to pack your data over async I/O, you were out of luck.
In particular, there was no way to use the RPC system with the packed codec.&lt;/p&gt;

&lt;p&gt;That has changed now, with
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/pull/296&quot;&gt;the addition&lt;/a&gt;
of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp_futures::serialize_packed&lt;/code&gt; module.
It includes standalone functions
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serialize_packed::try_read_message()&lt;/code&gt; and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serialize_packed::write_message()&lt;/code&gt;, as well
as wrappers&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PackedRead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncRead&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PackedWrite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncWrite&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which can be plugged into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp_rpc::twoparty::VatNetwork::new()&lt;/code&gt;
to enable packed RPC.&lt;/p&gt;

</description>
                                <pubDate>Thu, 03 Nov 2022 00:00:00 -0400</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2022/11/03/0.15-release.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2022/11/03/0.15-release.html</guid>
                        </item>
                
                        <item>
                                <title>atomic read limiting</title>
                                <description>&lt;p&gt;Today I’m releasing capnproto-rust version 0.14.
The main change is a new
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/c9b12bc765d5cc4e711890b97f065b855516ba71/capnp/Cargo.toml#L40-L43&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_reader&lt;/code&gt;&lt;/a&gt;
feature that allows messages to be shared between multiple threads.
With the new feature, you can, for example, wrap a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::message::Reader&lt;/code&gt;
with &lt;a href=&quot;https://crates.io/crates/lazy_static&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lazy_static&lt;/code&gt;&lt;/a&gt; or
&lt;a href=&quot;https://crates.io/crates/once_cell&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;once_cell&lt;/code&gt;&lt;/a&gt; and then read it from anywhere else
in your program.
Previously, doing so was not possible because the
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/c9b12bc765d5cc4e711890b97f065b855516ba71/capnp/src/message.rs#L38-L55&quot;&gt;message traversal limit&lt;/a&gt;
was tracked through a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&lt;/code&gt;, causing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message::Reader&lt;/code&gt; to not be
&lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Sync.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt;&lt;/a&gt;.
Now, when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync_reader&lt;/code&gt; is enabled, the traversal limit
is tracked through an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicUsize&lt;/code&gt;, which can be safely
shared between threads.&lt;/p&gt;

&lt;p&gt;To minimize the performance impact, the new implementation uses
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ordering::Relaxed&lt;/code&gt; when accessing the atomic counter.
When I measured the performance on a few benchmarks,
I was initially discouraged because
&lt;a href=&quot;https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html#method.fetch_sub&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_sub()&lt;/code&gt;&lt;/a&gt;
seemed to be slowing things down significantly.
Fortunately, I found that splitting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_sub()&lt;/code&gt; into separate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store()&lt;/code&gt;
steps recovered the lost time.
(Such a split may cause the read limiter to undercount reads,
but we are okay with that level of imprecision.)
With the &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/c9b12bc765d5cc4e711890b97f065b855516ba71/capnp/src/private/read_limiter.rs#L54-L71&quot;&gt;most recent version&lt;/a&gt;,
I am unable to detect any speed difference between the new atomic implementation
and the old &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cell&lt;/code&gt;-based one.&lt;/p&gt;

&lt;p&gt;I would have liked to unconditionally enable atomic read limiting,
but unfortunately &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicUsize&lt;/code&gt; is not available on all platforms.
For example, rustc
does not support any atomics on
&lt;a href=&quot;https://github.com/rust-lang/rust/blob/1b6b06a03a00a7c9f156bff130b72e90b79e1127/compiler/rustc_target/src/spec/riscv32i_unknown_none_elf.rs#L15&quot;&gt;riscv32i-unknown-none-elf&lt;/a&gt;.
(I am unsure whether that’s an inherent property of the platform,
or whether it’s an implementation hole that could be filled in later.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/appaquet&quot;&gt;@appaquet&lt;/a&gt; deserves credit
for submitting &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/pull/201&quot;&gt;the pull request&lt;/a&gt;
with this change and
for patiently iterating on it with me.&lt;/p&gt;
</description>
                                <pubDate>Sat, 19 Dec 2020 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2020/12/19/atomic-read-limiting.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2020/12/19/atomic-read-limiting.html</guid>
                        </item>
                
                        <item>
                                <title>no_std support</title>
                                <description>&lt;p&gt;Over the past few years,
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/issues/71&quot;&gt;many people have expressed interest&lt;/a&gt;
in using capnproto-rust in &lt;a href=&quot;https://rust-embedded.github.io/book/intro/no-std.html&quot;&gt;no_std&lt;/a&gt; environments
– that is, without pulling in the Rust standard library.
Today I’m happy to announce that the latest release, version 0.13.0, supports that.&lt;/p&gt;

&lt;p&gt;To use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt; capnproto-rust,
update your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cargo.toml&lt;/code&gt; to the new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; version and disable default features, like this:&lt;/p&gt;

&lt;div class=&quot;language-toml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;[capnp.dependencies]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.13&quot;&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;default-features&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This turns off the new
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/e2836823318d95668f10443d9f2feea8378ae95f/capnp/Cargo.toml#L36-L38&quot;&gt;“std” feature flag&lt;/a&gt;
in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; crate.
In turn, that feature controls a
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/e2836823318d95668f10443d9f2feea8378ae95f/capnp/src/lib.rs#L30&quot;&gt;crate-level &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt; attribute&lt;/a&gt;
and gates the parts of the crate that depend on the standard library.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;To see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt; capnproto-rust in action,
check out this &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/tree/master/example/wasm-hello-world&quot;&gt;new example&lt;/a&gt;
that passes data to a WebAssembly function through a Cap’n Proto message.
I observed the size of this example’s generated wasm code to shrink from
1.6MB down to 660KB when I added &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#![no_std]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;io-traits&quot;&gt;I/O traits&lt;/h2&gt;

&lt;p&gt;The biggest challenge in getting capnproto-rust to work with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt; was dealing with
input/output traits.
In previous releases, capnproto-rust defined its main serialization functions in terms of
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::io::Read&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::io::Write&lt;/code&gt;. That would be a problem in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt; context,
because those traits are &lt;a href=&quot;https://github.com/rust-lang/rust/issues/48331&quot;&gt;stuck in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The solution I settled on was to define custom
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/e2836823318d95668f10443d9f2feea8378ae95f/capnp/src/io.rs#L9&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::io::Read&lt;/code&gt;&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/e2836823318d95668f10443d9f2feea8378ae95f/capnp/src/io.rs#L44&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp::io::Write&lt;/code&gt;&lt;/a&gt;
traits, and then to define the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; serialization functions in terms of those.&lt;/p&gt;

&lt;p&gt;Blanket impls like the following then allow existing call sites to
continue to work without being altered:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[cfg(feature=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;std&quot;&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std_impls&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;why-now&quot;&gt;Why now?&lt;/h2&gt;

&lt;p&gt;Two recent Rust developments paved the way for today’s release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/rust-lang/rust/pull/59675&quot;&gt;stabilization of the alloc crate&lt;/a&gt;
means that collections like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vec&lt;/code&gt; are now usable with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_std&lt;/code&gt;. (capnproto-rust strives
to minimize allocations, but still relies on the global allocator for some things like
messages with a dynamic number of segments.)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/69033&quot;&gt;no_std support for async/await&lt;/a&gt; means that
we can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt; blocks wherever we want. Previously, we would have needed to define
some custom &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; implementations to avoid putting an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt; block in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; crate.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;Many people contributed useful ideas in the discussion that led up to the 0.13 release.
I am especially grateful to
&lt;a href=&quot;https://github.com/nicholastmosher&quot;&gt;nicholastmosher&lt;/a&gt;
and &lt;a href=&quot;https://github.com/bbqsrc&quot;&gt;bbqsrc&lt;/a&gt;
for submitting diffs that explored the
design space.&lt;/p&gt;
</description>
                                <pubDate>Sat, 06 Jun 2020 00:00:00 -0400</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2020/06/06/no-std-support.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2020/06/06/no-std-support.html</guid>
                        </item>
                
                        <item>
                                <title>new feature to allow unaligned buffers</title>
                                <description>&lt;p&gt;&lt;a href=&quot;/capnproto-rust/2020/01/11/unaligned-memory-access.html&quot;&gt;Last week&lt;/a&gt; I wrote about
how capnproto-rust might relax its memory alignment requirements
and what the performance cost of that might look like.
The &lt;a href=&quot;https://www.reddit.com/r/rust/comments/en9fmn/should_capnprotorust_force_users_to_worry_about/&quot;&gt;ensuing discussion&lt;/a&gt;
taught me that memory alignment issues can be thornier than I had thought,
and it strengthened my belief that capnproto-rust users ought be shielded
from such issues. Since then, working with the helpful feedback
of many people, I have implemented what I consider to be a satisfactory resolution to the problem.
Today I’m releasing it as part of capnproto-rust version 0.12.
The new version not only provides a safe interface for unaligned memory, but also maintains high performance
for aligned memory.&lt;/p&gt;

&lt;h2 id=&quot;new-feature-flag&quot;&gt;New Feature Flag&lt;/h2&gt;
&lt;p&gt;Cargo supports a
&lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section&quot;&gt;feature-flags&lt;/a&gt;
mechanism, whereby a crate can declare parts of its functionality to be optional, with enablement or disablement
happening at compile time.&lt;/p&gt;

&lt;p&gt;As of version 0.12, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; crate has a new
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/9fa83b89eebb10aba6a1181bb7e4f9a4fad916f6/capnp/Cargo.toml#L30-L32&quot;&gt;feature flag called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt;&lt;/a&gt;.
When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; is enabled, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; makes no assumptions about the alignment of its data.
In particular, it can read a message in place from any array of bytes via
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/9fa83b89eebb10aba6a1181bb7e4f9a4fad916f6/capnp/src/serialize.rs#L57-L65&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_message_from_flat_slice()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On the flip side, when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; enabled, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; requires that message segments are 8-byte aligned,
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/9fa83b89eebb10aba6a1181bb7e4f9a4fad916f6/capnp/src/private/arena.rs#L92-L100&quot;&gt;returning an error&lt;/a&gt;
if it detects that’s not the case.
The 8-byte alignment is then used whenever
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; loads or stores a primitive value in a message.&lt;/p&gt;

&lt;p&gt;With the new interface, there is no longer a need for the problematic &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe fn Word::bytes_to_words()&lt;/code&gt;,
so that method no longer exists.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;The downside of enabling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; feature is that some operations require
more instructions on certain compilation targets.
To better understand the performance cost,
I ran capnproto-rust’s
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/tree/9fa83b89eebb10aba6a1181bb7e4f9a4fad916f6/benchmark&quot;&gt;benchmark suite&lt;/a&gt;
on three different computers: my laptop (x86_64), an EC2 ARM64 instance (aarch64), and a Raspberry Pi Zero (armv6).
I compared three different capnproto-rust versions: 0.11, 0.12, and 0.12 with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As expected, on all of the computers
the 0.12 version without the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; feature performed about the same version 0.11
(within measurement noise).
When I enabled the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; feature, the only computer where there
was a noticeable performance impact was the Raspberry Pi,
where the benchmarks slowed down between 10 and 20 percent.
This also was within my expectations, though I had been hoping
it would be lower. (If the performance impact had been negligible,
I would likely not have bothered to make &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unaligned&lt;/code&gt; an optional feature; instead
I would have made it the &lt;em&gt;only&lt;/em&gt; supported mode.)&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;Validation&lt;/h2&gt;

&lt;p&gt;Following &lt;a href=&quot;https://www.reddit.com/r/rust/comments/en9fmn/should_capnprotorust_force_users_to_worry_about/fedr67j/&quot;&gt;ralfj’s suggestion&lt;/a&gt;,
I also performed some testing with &lt;a href=&quot;https://github.com/rust-lang/miri&quot;&gt;miri&lt;/a&gt;
to increase my confidence that there is no lurking undefined behavior.
I added &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/9fa83b89eebb10aba6a1181bb7e4f9a4fad916f6/capnp/src/private/layout_test.rs#L24&quot;&gt;some tests&lt;/a&gt;
that specifically force 1-byte alignment.&lt;/p&gt;

&lt;p&gt;I was pleasantly surprised to learn how easy it is to run miri these days:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rustup component add miri
$ cargo miri test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I recommend that you try this on your own projects!&lt;/p&gt;

</description>
                                <pubDate>Sun, 19 Jan 2020 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2020/01/19/new-feature-to-allow-unaligned-buffers.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2020/01/19/new-feature-to-allow-unaligned-buffers.html</guid>
                        </item>
                
                        <item>
                                <title>unaligned memory access</title>
                                <description>&lt;p&gt;A core feature of capnproto-rust is its ability to
read messages directly from memory without copying the data into auxiliary structures.
Unfortunately, this functionality is a bit tricky to use correctly,
as can be seen in its primary interface, the
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/d1988731887b2bbb0ccb35c68b9292d98f317a48/capnp/src/serialize.rs#L76-L81&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_message_from_words()&lt;/code&gt;&lt;/a&gt;
function, whose input is of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[Word]&lt;/code&gt;.
In the common case where you want to read from a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[u8]&lt;/code&gt;,
you must first call the unsafe function
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/blob/d1988731887b2bbb0ccb35c68b9292d98f317a48/capnp/src/lib.rs#L82-L88&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes_to_words()&lt;/code&gt;&lt;/a&gt;
in order to get a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[Word]&lt;/code&gt;.
It is only safe to call this function if you know that your data is
8-byte aligned &lt;strike&gt;or if you know that your code will only run on processors
that permit unaligned memory access&lt;/strike&gt; (EDIT: ralfj &lt;a href=&quot;https://www.reddit.com/r/rust/comments/en9fmn/should_capnprotorust_force_users_to_worry_about/fedhjtk/&quot;&gt;informs me&lt;/a&gt; that misaligned loads are never okay.)
The former condition can be difficult to meet, especially if your memory comes from
an external library like sqlite or zmq where no alignment guarantees are given&lt;strike&gt;,
and the latter condition feels like an unfair burden, both in terms of demanding that
you understand a rather subtle concept, and in terms of limiting where your software can run&lt;/strike&gt;.
So it’s easy to  understand why someone might shy away from calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes_to_words()&lt;/code&gt;
and, in turn, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_message_from_words()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Can we do better? Ideally, capnproto-rust would safely operate directly on input of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;[u8]&lt;/code&gt;.
We can in fact adapt the code to do that, but it comes at a cost: processors that don’t natively
support unaligned access will need to do some more work every time that capnproto-rust
loads or stores a multi-byte value.
To get some idea of what that extra work looks like, let’s examine
the assembly code emitted by rustc!
(A better way to quantify the cost would be to perform controlled experiments on actual hardware,
but that’s a more involved project than I’d like to tackle right now.)&lt;/p&gt;

&lt;p&gt;Below is some code representing a bare-bones simplification of the two approaches to memory access.
(The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[no_std]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[no_mangle]&lt;/code&gt; attributes are to simpify the assembly code.)&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#![no_std]&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;direct_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_le&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;indirect_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_le_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;direct_load()&lt;/code&gt; function represents the current state of affairs in capnproto-rust.
It loads a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u64&lt;/code&gt; by casting a pointer of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*const u8&lt;/code&gt; to type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*const u64&lt;/code&gt; and then deferencing that pointer.
This is only safe if the input is 8-byte aligned &lt;strike&gt;or if the processor can handle unaligned access&lt;/strike&gt;.
(EDIT: again, see ralfj’s &lt;a href=&quot;https://www.reddit.com/r/rust/comments/en9fmn/should_capnprotorust_force_users_to_worry_about/fedhjtk/&quot;&gt;reddit comment&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indirect_load()&lt;/code&gt; function represents the safer alternative. We expect this to
sometimes require more work than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;direct_load()&lt;/code&gt;, but it has the advantage of
being easier to use and understand.&lt;/p&gt;

&lt;p&gt;To compare the assembly code generated by these functions, I installed
a variety of rustc targets using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rustup&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rustup target add $TARGET
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and then for each target compiled the code with:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rustc -O --crate-type=lib test.rs --target=$TARGET --emit=asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The results, edited to only include the relevant bits of code, are show below.&lt;/p&gt;

&lt;h2 id=&quot;x86_64-unknown-linux-gnu&quot;&gt;x86_64-unknown-linux-gnu&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	movq	(%rdi), %rax
	retq

indirect_load:
	movq	(%rdi), %rax
	retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;i686-unknown-linux-gnu&quot;&gt;i686-unknown-linux-gnu&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	movl	4(%esp), %ecx
	movl	(%ecx), %eax
	movl	4(%ecx), %edx
	retl

indirect_load:
	movl	4(%esp), %ecx
	movl	(%ecx), %eax
	movl	4(%ecx), %edx
	retl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;aarch64-unknown-linux-gnu&quot;&gt;aarch64-unknown-linux-gnu&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	ldr	x0, [x0]
	ret

indirect_load:
	ldr	x0, [x0]
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wasm32-wasi&quot;&gt;wasm32-wasi&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	local.get	0
	i64.load	0

indirect_load:
	local.get	0
	i64.load	0:p2align=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;armv7-unknown-linux-gnueabi&quot;&gt;armv7-unknown-linux-gnueabi&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	ldrd	r0, r1, [r0]
	bx	lr

indirect_load:
	ldr	r2, [r0]
	ldr	r1, [r0, #4]
	mov	r0, r2
	bx	lr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;powerpc-unknown-linux-gnu&quot;&gt;powerpc-unknown-linux-gnu&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	li 4, 4
	lwbrx 5, 3, 4
	lwbrx 4, 0, 3
	mr 3, 5
	blr

indirect_load:
	li 4, 4
	lwbrx 5, 3, 4
	lwbrx 4, 0, 3
	mr 3, 5
	blr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mips-unknown-linux-gnu&quot;&gt;mips-unknown-linux-gnu&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	lw	$1, 4($4)
	wsbh	$1, $1
	rotr	$2, $1, 16
	lw	$1, 0($4)
	wsbh	$1, $1
	jr	$ra
	rotr	$3, $1, 16

indirect_load:
	lwl	$1, 4($4)
	lwr	$1, 7($4)
	wsbh	$1, $1
	rotr	$2, $1, 16
	lwl	$1, 0($4)
	lwr	$1, 3($4)
	wsbh	$1, $1
	jr	$ra
	rotr	$3, $1, 16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;riscv32i-unknown-none-elf&quot;&gt;riscv32i-unknown-none-elf&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;direct_load:
	addi	sp, sp, -16
	sw	ra, 12(sp)
	sw	s0, 8(sp)
	addi	s0, sp, 16
	lw	a2, 0(a0)
	lw	a1, 4(a0)
	mv	a0, a2
	lw	s0, 8(sp)
	lw	ra, 12(sp)
	addi	sp, sp, 16
	ret

indirect_load:
	addi	sp, sp, -16
	sw	ra, 12(sp)
	sw	s0, 8(sp)
	addi	s0, sp, 16
	lbu	a1, 1(a0)
	slli	a1, a1, 8
	lbu	a2, 0(a0)
	or	a1, a1, a2
	lbu	a2, 3(a0)
	slli	a2, a2, 8
	lbu	a3, 2(a0)
	or	a2, a2, a3
	slli	a2, a2, 16
	or	a2, a2, a1
	lbu	a1, 5(a0)
	slli	a1, a1, 8
	lbu	a3, 4(a0)
	or	a1, a1, a3
	lbu	a3, 6(a0)
	lbu	a0, 7(a0)
	slli	a0, a0, 8
	or	a0, a0, a3
	slli	a0, a0, 16
	or	a1, a0, a1
	mv	a0, a2
	lw	s0, 8(sp)
	lw	ra, 12(sp)
	addi	sp, sp, 16
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;As expected, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;direct_load()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indirect_load()&lt;/code&gt; generate the same
assembly code for many targets. These are presumably exactly the targets that support
unaligned memory access. On targets where different instructions were generated
for the two functions, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indirect_load()&lt;/code&gt; typically requires somewhere between 2x and 3x the
number of instructions of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;direct_load()&lt;/code&gt;. Is that an acceptable cost? How much of an
impact would it have in the context of a complete real-world program? I don’t know!
I’m inclined to believe that the usability benefits of the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indirect_load()&lt;/code&gt; approach outweigh its performance
cost, especially since that cost is probably zero or negligible on the most commonly used targets,
but maybe that’s not true?
I encourage any readers of this post who have thoughts on the matter to comment
on this &lt;a href=&quot;https://github.com/capnproto/capnproto-rust/issues/101&quot;&gt;github issue&lt;/a&gt;.&lt;/p&gt;
</description>
                                <pubDate>Sat, 11 Jan 2020 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2020/01/11/unaligned-memory-access.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2020/01/11/unaligned-memory-access.html</guid>
                        </item>
                
                        <item>
                                <title>async/await</title>
                                <description>&lt;p&gt;Today I’m releasing version 0.11.0 of capnproto-rust,
with support for
&lt;a href=&quot;https://blog.rust-lang.org/2019/11/07/Async-await-stable.html&quot;&gt;async/await&lt;/a&gt;!
The updated RPC system works with any futures-0.3-enabled executor
(e.g. tokio, async-std) – you just need to provide it
with objects that implement the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futures::io::AsyncRead&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futures::io::AsyncWrite&lt;/code&gt; traits.&lt;/p&gt;

&lt;p&gt;The stabilization of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::future::Future&lt;/code&gt; allowed me to eliminate
an annoying
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/0e825eecbf2337d1fb2caed015bfa4862a195d40#diff-c0b507abb73596f7f82a1c80ac680e54L31&quot;&gt;optional dependecy&lt;/a&gt;
on futures-0.1
in the base &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capnp&lt;/code&gt; crate, and in general the update allowed me to
&lt;a href=&quot;https://github.com/capnproto/capnproto-rust/commit/0e825eecbf2337d1fb2caed015bfa4862a195d40&quot;&gt;delete a lot of code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my experience, async/await can vastly simplify concurrent programming,
especially in the case where you have a single-threaded event loop
and you want to share mutable data among multiple tasks.&lt;/p&gt;

&lt;p&gt;Probably the hardest part of this update was wrapping my head around &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;.
My biggest takeaway message on that topic is:
if you get into trouble, try wrapping your object with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box::pin()&lt;/code&gt;.
Curiously, doing so will give you an object that is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unpin&lt;/code&gt; – which is often
exactly what you need!&lt;/p&gt;

</description>
                                <pubDate>Fri, 06 Dec 2019 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2019/12/06/async-await.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2019/12/06/async-await.html</guid>
                        </item>
                
                        <item>
                                <title>cargo-fuzz findings</title>
                                <description>&lt;p&gt;After the
&lt;a href=&quot;https://www.reddit.com/r/rust/comments/5va0mi/cargofuzz_an_easy_way_to_fuzz_your_crates/&quot;&gt;announcement&lt;/a&gt;
of &lt;a href=&quot;https://github.com/rust-fuzz/cargo-fuzz&quot;&gt;cargo-fuzz&lt;/a&gt; last week,
I decided to try using it to search for bugs in capnproto-rust.
For a long time I had been meaning to try out
&lt;a href=&quot;https://github.com/rust-fuzz/afl.rs&quot;&gt;afl.rs&lt;/a&gt;,
a similar fuzz-testing tool about which I had heard lots of good things,
but its nontrivial setup costs were enough to deter me.
Fortunately, cargo-fuzz is very simple and fast to get running.
It quickly found several issues in capnproto-rust, all of which have been fixed
in the &lt;a href=&quot;https://crates.io/crates/capnp&quot;&gt;latest release&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;panic-on-invalid-input-fixed-in-6f9bbdca&quot;&gt;Panic on invalid input (fixed in &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/6f9bbdca5f77146f6f1ff0297295c3fded3a01a6&quot;&gt;6f9bbdca&lt;/a&gt;)&lt;/h4&gt;

&lt;p&gt;The original
&lt;a href=&quot;https://github.com/sandstorm-io/capnproto/blob/01f6d5e4ff05fcd67e968b50120dba3fbbb38afb/c%2B%2B/src/capnp/layout.c%2B%2B#L1875&quot;&gt;C++ code&lt;/a&gt;
suggests that the branches for dealing with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Far&lt;/code&gt; pointers in
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;total_size()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy_pointer()&lt;/code&gt; are unreachable,
so I had translated them into panics.
It turns out that these branches can in fact be reached
due to invalid input, rather than any bugs in the code.
In the C++ version, this means that a somewhat
misleading exception will be thrown;
I’ve submitted &lt;a href=&quot;https://github.com/sandstorm-io/capnproto/pull/421&quot;&gt;a pull request&lt;/a&gt;
to make the exception more accurate.
The problem is more serious in the Rust version,
because Rust makes a sharp distinction between panics and error &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result&lt;/code&gt;s.&lt;/p&gt;

&lt;h4 id=&quot;cpu-amplifications-fixed-in-e89f162b-66def413&quot;&gt;CPU amplifications (fixed in &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/e89f162b3545096aec77a62157463437d6959ac5&quot;&gt;e89f162b&lt;/a&gt;, &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/66def4134e8b4fbc2459d77e72717e445175879c&quot;&gt;66def413&lt;/a&gt;)&lt;/h4&gt;

&lt;p&gt;One way to attempt to mount a denial-of-service attack on a
consumer of Cap’n Proto messages is to carefully craft messages
that could trick the consumer into doing lots of work. For example,
if you send a cyclic structure, the consumer might go into an infinite loop
trying to read it.
To protect against such attacks, message readers in capnproto-rust
have an adjustable traversal limit, indicating how many bytes
are allowed to be read before an error is returned.
Reads of zero-sized structs should also count against
this limit, as was observed in these
&lt;a href=&quot;https://github.com/sandstorm-io/capnproto/blob/f29bb0dafbe081960f9b508528138d5f99f83b7b/security-advisories/2015-03-02-2-all-cpu-amplification.md&quot;&gt;bug&lt;/a&gt;
&lt;a href=&quot;https://github.com/sandstorm-io/capnproto/blob/f29bb0dafbe081960f9b508528138d5f99f83b7b/security-advisories/2015-03-05-0-c%2B%2B-addl-cpu-amplification.md&quot;&gt;reports&lt;/a&gt;
for capnproto-c++ in 2015.
I thought that I had completely updated capnproto-rust with
fixes for this problem, but apparently I had missed two cases. :-(&lt;/p&gt;

&lt;h4 id=&quot;panics-on-todos-fixed-in-4c8d5f3-77dc713b-10f37267-3521d4e2&quot;&gt;Panics on TODOs (fixed in &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/4c8d5f369335dc6deef6f9d1e818da5d47e2a36d&quot;&gt;4c8d5f3&lt;/a&gt;, &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/77dc713b8486bf61fe657cb82f5d6cb351e76306&quot;&gt;77dc713b&lt;/a&gt;, &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/10f37267e3c94d861e946f91dada61fa4dc085ee&quot;&gt;10f37267&lt;/a&gt;, &lt;a href=&quot;https://github.com/dwrensha/capnproto-rust/commit/3521d4e25877d038154350d9ea5621779724ca5c&quot;&gt;3521d4e2&lt;/a&gt;)&lt;/h4&gt;

&lt;p&gt;The fuzzer managed to find some explicit panics in capnproto-rust
that were filling in holes of unimplemented functionality.
I had forgotten that such holes still existed.
After cargo-fuzz found these,
I went ahead and implemented the functionality.
At first I was too lazy to write a test case to cover the new code,
but before going to bed that night I did
set up cargo-fuzz to run on it.
By the next morning, cargo-fuzz had found a memory safety issue
in the new code! Even better, the test case it generated
was rather clever and gave me a good starting point for writing the
&lt;a href=&quot;https://github.com/dwrensha/capnpc-rust/blob/4bd89ab2fccc1386b3b608a663e4adfbb199d695/test/test.rs#L772-L820&quot;&gt;test&lt;/a&gt;
that I later added to the capnproto-rust test suite to cover the new functionality.&lt;/p&gt;

</description>
                                <pubDate>Mon, 27 Feb 2017 00:00:00 -0500</pubDate>
                                <link>http://dwrensha.github.io/capnproto-rust/2017/02/27/cargo-fuzz.html</link>
                                <guid isPermaLink="true">http://dwrensha.github.io/capnproto-rust/2017/02/27/cargo-fuzz.html</guid>
                        </item>
                
        </channel>
</rss>
